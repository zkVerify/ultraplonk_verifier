// // Copyright 2024, The Horizen Foundation
// // SPDX-License-Identifier: Apache-2.0
// //
// // Licensed under the Apache License, Version 2.0 (the "License");
// // you may not use this file except in compliance with the License.
// // You may obtain a copy of the License at
// //
// //     http://www.apache.org/licenses/LICENSE-2.0
// //
// // Unless required by applicable law or agreed to in writing, software
// // distributed under the License is distributed on an "AS IS" BASIS,
// // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// // See the License for the specific language governing permissions and
// // limitations under the License.

// use clap::{Parser, Subcommand};
// use std::path::PathBuf;

// #[derive(Parser, Debug)]
// #[command(name = "noir-cli")]
// #[command(
//     about = "Utility for handling zero-knowledge proof verification keys and proof data in Noir-lang. Converts Solidity verification keys to binary format, processes proof data from JSON files, and verifies proofs against public inputs and verification keys."
// )]
// #[command(version)]
// pub struct Cli {
//     #[command(subcommand)]
//     pub command: Commands,

//     /// Enable verbose output
//     #[arg(long)]
//     pub verbose: bool,
// }

// #[derive(Subcommand, Debug)]
// pub enum Commands {
//     /// Convert Solidity verification key to binary format
//     Key {
//         /// Input file for verification key
//         #[arg(long)]
//         input: PathBuf,

//         /// Output file for verification key [or stdout if not specified]
//         #[arg(long)]
//         output: Option<PathBuf>,
//     },
//     /// Take in vk as generated by Noir toolchain and output it in hex format.
//     KeyToHex {
//         /// Input file for verification key
//         #[arg(long)]
//         input: PathBuf,

//         /// Output file for verification key in hex format [or stdout if not specified]
//         #[arg(long)]
//         output: Option<PathBuf>,
//     },
//     /// Process proof data from JSON file and generate output files for proof and
//     /// public inputs suitable to be submitted to zkVerify.
//     /// To be used for Noir versions <= 0.30.0.
//     ProofData {
//         /// Input file for proof and public inputs
//         #[arg(long)]
//         input_json: PathBuf,

//         /// Output file for proof data [or stdout if not specified]
//         #[arg(long)]
//         output_proof: Option<PathBuf>,

//         /// Output file for verification key [or stdout if not specified]
//         #[arg(long)]
//         output_pubs: Option<PathBuf>,
//     },
//     /// Parse proof as generated by bb tool from Noir toolchain and output files for proof and
//     /// public inputs suitable to be submitted to zkVerify. Both in hex and binary format.
//     /// To be used for Noir versions >= 0.31.0.
//     ProofDatav2 {
//         /// Number of public inputs supported by the circuit
//         #[arg(short)]
//         num_inputs: usize,

//         /// Proof as generated by bb tool
//         #[arg(long)]
//         input_proof: PathBuf,

//         /// Output file for proof data [or stdout if not specified]
//         #[arg(long)]
//         output_proof: Option<PathBuf>,

//         /// Output file for verification key [or stdout if not specified]
//         #[arg(long)]
//         output_pubs: Option<PathBuf>,
//     },
//     /// Verify proof with key
//     Verify {
//         /// Proof file
//         #[arg(long)]
//         proof: PathBuf,

//         /// Input file for public inputs
//         #[arg(long)]
//         pubs: PathBuf,

//         /// Verification key file
//         #[arg(long)]
//         key: PathBuf,
//     },
// }
